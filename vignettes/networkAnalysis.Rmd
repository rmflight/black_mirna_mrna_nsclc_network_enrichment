# Network Analysis

```{r setup}
library(pBlackNetworkAnalysis)
library(STRINGdb)
library(graph)
library(igraph)
library(RCytoscape)
library(org.Hs.eg.db)
library(hgu133plus2.db)
library(categoryCompare)
library(GO.db)
library(xtable)
library(KEGGREST)
library(KEGGgraph)

stringFileLoc <- "/mlab/data/rmflight/Documents/stringdatabase_91/"
```


# First question

* Of the genes that map to STRING, which ones map to AKT(??) and EGFR pathway? 
* any other pathways?

## Data

mRNA and miRNA from NSCLC cell lines with differential response to erolotinib (EGFR inhibitor). Affy U133 2.0, miRNA TaqMan card.

After reading in the data, what are our options?

* Use *STRINGdb* to get PPI (definite)
* Use *reactomedb* to get pathway membership (and consider co-occurence in pathway as an edge)
* Use *KEGGREST* and *KEGGGraph* to get pathway links between genes

stringdb - http://www.bioconductor.org/packages/release/bioc/vignettes/STRINGdb/inst/doc/STRINGdb.pdf
reactomedb

LOO cross-validated PLS results giving interactions between miRNA and mRNA.

```{r loadData}
mirData <- read.table("compiledinteractiondata.csv", header=TRUE, stringsAsFactors=FALSE, sep=",")
newmRNA <- sapply(seq(1, nrow(mirData)), function(x){
  useID <- mirData$mRNA[x]
  nID <- nchar(useID)
  substring(useID, 2, nID)
})
mirData$mRNA <- newmRNA
```

What is the distribution of associations of miRNA's to mRNA from the PLS results?

```{r linkDistribution}
splitMRNA <- split(mirData$miRNA, mirData$mRNA)
splitCount <- sapply(splitMRNA, length)
hist(splitCount)
```

Based on this (and comments from P Black), we will restrict our analysis to those Affy probesets with at least **5** miRNA associations.

```{r filterMRNA}
nMin <- 5
sum(splitCount >= nMin)

useMRNA <- data.frame(gene=names(splitCount)[splitCount >= nMin], stringsAsFactors=FALSE)
```

We want to convert our *Affy* ID's to other gene symbols and names for further use.

```{r convertID}
outMRNA <- select(hgu133plus2.db, useMRNA$gene, c("SYMBOL", "GENENAME", "ENTREZID"), "PROBEID")
```

## STRING PPI

We are doing a programmatic query of STRING because the website is rather limiting in how much data it will show you. So even though we will initially only look at direct interactions, we may get more information than is available off the website, as the website initially limits you to 10 interactions unless you explicitly ask it for more.

### Translate to STRING ID

We have downloaded the STRING ID to alias file previously, and we will use our own function to do translation because we get off by 1 errors for the genes we started with.

```{r getSTRINGID}
stringIDFile <- file.path(stringFileLoc, "9606__protein_aliases_tf.tsv.gz")
outMRNA_mapped <- map2STRING(outMRNA, "SYMBOL", stringIDFile)
outMRNA_mapped$ENSEMBLPROT <- substring(outMRNA_mapped$protein_id, 6, 20)
```

We've previously downloaded the STRINGdb files for human. Let's load them up and parse them down.

```{r stringData}
stringData <- read.table(file.path(stringFileLoc, "9606.protein.links.detailed.v9.1.txt"), header=TRUE, sep=" ", stringsAsFactors=FALSE)
head(stringData)
```

We will use the cutoff for `combined_score` of 400 (the default in STRING itself), and then filter down to just those things with co-expression, experimental or database evidence.

```{r filterData}
combScore <- 400
minScores <- c(experimental=400, database=400, coexpression=400)
passesScore <- rep(FALSE, nrow(stringData))
invisible(lapply(names(minScores), function(evidence){
  passesScore <<- passesScore | (stringData[, evidence] >= minScores[evidence])
}))
passesScore <- passesScore & (stringData$combined_score >= combScore)
head(stringData[passesScore,])
```

```{r trueFilter}
stringData <- stringData[passesScore,]
```

Now that we have possible interactions, we need to filter them down to links that involve our actual proteins of interest, and any links between those proteins.

```{r getUsefulLinks}
rnd1 <- which((stringData$protein1 %in% outMRNA_mapped$protein_id) | (stringData$protein2 %in% outMRNA_mapped$protein_id))

useNodes <- unique(c(stringData$protein1[rnd1], stringData$protein2[rnd1]))

hasP1 <- stringData$protein1 %in% useNodes
hasP2 <- stringData$protein2 %in% useNodes

useEdges <- hasP1 & hasP2

stringEdges <- stringData[useEdges,]
nrow(stringEdges)

# how many of our genes are actually in the network?
sum(outMRNA_mapped$protein_id %in% unique(c(stringEdges$protein1, stringEdges$protein2)))
```

Now we should instantiate the network, and start adding information to it.

```{r createNetwork}
allNodes <- unique(c(stringEdges$protein1, stringEdges$protein2))
stringGraph <- graphNEL(nodes=allNodes, edgemode="directed")
stringGraph <- addEdge(stringEdges$protein1, stringEdges$protein2, stringGraph)
```

We also need to know some other stuff about the nodes.

```{r otherNodeData}
trimNodes <- substring(allNodes, 6, 20)
nodeInfo <- select(org.Hs.eg.db, trimNodes, c("SYMBOL", "GENENAME", "ENTREZID"), keytype="ENSEMBLPROT")
nodeInfo$nodeID <- paste("9606.", nodeInfo$ENSEMBLPROT, sep="")

# this last section is to make sure we are using the info from the affy chip for those nodes we already had.
hasNodes <- nodeInfo$nodeID %in% outMRNA_mapped$protein_id
nodeInfo <- nodeInfo[!hasNodes,]

outMRNA_mapped$nodeID <- outMRNA_mapped$protein_id
nodeInfo <- rbind(nodeInfo, outMRNA_mapped[,c("ENSEMBLPROT", "SYMBOL", "GENENAME", "ENTREZID", "nodeID")])
nodeInfo <- nodeInfo[(nodeInfo$nodeID %in% nodes(stringGraph)),]

dupNodes <- duplicated(nodeInfo$nodeID)
nodeInfo <- nodeInfo[!dupNodes,]
```

We are also going to indicate which nodes originated from our original measurements

```{r addChipInfo}
nodeInfo$fromChip <- as.character(nodeInfo$nodeID %in% outMRNA_mapped$nodeID)
```

And add all that lovely data to our graph.

```{r addNodeData}
for (iName in c("ENSEMBLPROT", "SYMBOL", "GENENAME", "ENTREZID", "fromChip")){
  nodeDataDefaults(stringGraph, iName) <- ""
  attr(nodeDataDefaults(stringGraph, iName), "class") <- "STRING"
  nodeData(stringGraph, nodeInfo$nodeID, iName) <- nodeInfo[,iName]
}
```


### EIF4B / RAB8A

For a student application, trim down to just those things that connect to EIF4B / RAB8A.

```{r eifrab8}
eifrabInfo <- outMRNA_mapped[(outMRNA_mapped$SYMBOL %in% c("EIF4B", "RAB8A")),]

eifrabNodes <- eifrabInfo$nodeID

eifrabAttached <- adj(stringGraph, eifrabNodes)
eifrabSubNodes <- unique(c(eifrabNodes, unlist(eifrabAttached)))
eifrabGraph <- subGraph(eifrabSubNodes, stringGraph)
eifrabGraph
```

Visualize!

```{r visEIFRAB}
cw.eifrab <- CytoscapeWindow("eifrab", eifrabGraph)
displayGraph(cw.eifrab)
layoutNetwork(cw.eifrab, "fruchterman-rheingold")
setNodeLabelDirect(cw.eifrab, eifrabSubNodes, nodeData(eifrabGraph, eifrabSubNodes, "SYMBOL"))
redraw(cw.eifrab)
setNodeColorDirect(cw.eifrab, eifrabNodes, "#F5C46F")
redraw(cw.eifrab)
setNodeColorDirect(cw.eifrab, eifrabSubNodes[!(eifrabSubNodes %in% eifrabNodes)], "#6FA0F5")
redraw(cw.eifrab)
setDefaultEdgeColor(cw.eifrab, "#CCCCCC")
redraw(cw.eifrab)
setDefaultBackgroundColor(cw.eifrab, "#FFFFFF")
redraw(cw.eifrab)
```

```{r eifrabNodeData}
eifrabNodeData <- nodeInfo[(nodeInfo$nodeID %in% nodes(eifrabGraph)),]
eifrabNodeData[order(eifrabNodeData$SYMBOL),]
```


Looking at many of these, they appear to be part of complexes (EIF3, CNOT, EXOC, RPL, RPS, SNORD, SNORA). How many individual nodes would we remove if we collapsed these to single representatives? We will also remove anything that has "NA" for it's other identifiers.

```{r collapseNodes}
collapseSearch <- c("CNOT", "EIF3", "EXOC", "RPL", "RPS")

eifrabNodeData$collapseID <- eifrabNodeData$SYMBOL
eifrabNodeData <- eifrabNodeData[!(is.na(eifrabNodeData$SYMBOL)),]

for (checkCollapse in collapseSearch){
  whichCollapse <- grep(checkCollapse, eifrabNodeData$SYMBOL)
  eifrabNodeData$collapseID[whichCollapse] <- checkCollapse
}

length(unique(eifrabNodeData$collapseID))
```

So we've gone from a total of `r nrow(eifrabNodeData)` to `r length(unique(eifrabNodeData$collapseID))` nodes. Let's modify the graph and see if that improves matters.

```{r collapseGraph}
eifrabGraph <- subGraph(eifrabNodeData$nodeID, eifrabGraph)
edgemode(eifrabGraph) <- "undirected"

eifrabMatrix <- as(eifrabGraph, "matrix")

eifrabNew <- eifrabMatrix
eifrabNew <- rbind(eifrabNew, matrix(0, nrow=5, ncol=ncol(eifrabNew)))
eifrabNew <- cbind(eifrabNew, matrix(0, nrow=nrow(eifrabNew), ncol=5))
rownames(eifrabNew) <- c(rownames(eifrabMatrix), collapseSearch)
colnames(eifrabNew) <- c(colnames(eifrabMatrix), collapseSearch)

for (iCollapse in collapseSearch){
  useID <- eifrabNodeData$nodeID[(eifrabNodeData$collapseID %in% iCollapse)]
  
  for (inID in useID){
    hasRow <- rownames(eifrabNew)[eifrabNew[,inID] == 1]
    eifrabNew[hasRow, iCollapse] <- 1
    
    hasCol <- colnames(eifrabNew)[eifrabNew[inID,] == 1]
    eifrabNew[iCollapse, hasCol] <- 1
  }
}

for (iCollapse in collapseSearch){
  eifrabNew[iCollapse, iCollapse] <- 0
}

keepNodes <- c(eifrabNodeData$nodeID[!(eifrabNodeData$collapseID %in% collapseSearch)], collapseSearch)
eifrabNew <- eifrabNew[keepNodes, keepNodes]

eifrabNewGraph <- as(eifrabNew, "graphNEL")
```

Now we need to encode the data for it so we know what the nodes are again when we view them in a graph.

```{r eifrabData}
eifrabNewData <- eifrabNodeData[(eifrabNodeData$nodeID %in% nodes(eifrabNewGraph)),]
collapseData <- data.frame(ENSEMBLPROT=collapseSearch, SYMBOL=collapseSearch, GENENAME=collapseSearch, ENTREZID=collapseSearch, nodeID=collapseSearch, fromChip=FALSE, collapseID=collapseSearch, stringsAsFactors=FALSE)

eifrabNewData <- rbind(eifrabNewData, collapseData)

for (iName in c("ENSEMBLPROT", "SYMBOL", "GENENAME", "ENTREZID", "fromChip")){
  nodeDataDefaults(eifrabNewGraph, iName) <- ""
  attr(nodeDataDefaults(eifrabNewGraph, iName), "class") <- "STRING"
  nodeData(eifrabNewGraph, eifrabNewData$nodeID, iName) <- eifrabNewData[,iName]
}
eifrabNewGraph <- initEdgeAttribute(eifrabNewGraph, "weight", "numeric", 1)
```

Lets visualize this again!

```{r newEIFRAB}
eifrabNodes <- eifrabNewData$nodeID[eifrabNewData$SYMBOL %in% c("EIF4B", "RAB8A")]
eifrabNotNodes <- grep("^9606", eifrabNewData$nodeID, value=TRUE)
eifrabNotNodes <- eifrabNotNodes[!(eifrabNotNodes %in% eifrabNodes)]

cw.eif2 <- CytoscapeWindow("eif2", eifrabNewGraph)
displayGraph(cw.eif2)
setLayoutProperties(cw.eif2, layout.name="kamada-kawai-noweight", list(anticollisionStrength=4000, rest_length=100))
layoutNetwork(cw.eif2, "kamada-kawai-noweight")
redraw(cw.eif2)
setNodeLabelDirect(cw.eif2, nodes(eifrabNewGraph), nodeData(eifrabNewGraph, nodes(eifrabNewGraph), "SYMBOL"))
redraw(cw.eif2)
setNodeColorDirect(cw.eif2, eifrabNodes, "#F5C46F")
redraw(cw.eif2)
setNodeColorDirect(cw.eif2, eifrabNotNodes, "#6FA0F5")
redraw(cw.eif2)
setDefaultBackgroundColor(cw.eif2, "#FFFFFF")
redraw(cw.eif2)
setDefaultNodeSize(cw.eif2, 60)
redraw(cw.eif2)
setDefaultEdgeColor(cw.eif2, "#CCCCCC")
redraw(cw.eif2)
setDefaultNodeFontSize(cw.eif2, "20")
redraw(cw.eif2)
```


## Visualize

Now lets see what we can see.

```{r loadCytoscape}
cw <- CytoscapeWindow("stringgraph", stringGraph)
displayGraph(cw)
layoutNetwork(cw, "kamada-kawai")
```

Where are the original genes?

```{r selectOriginal}
orgNodes <- nodeInfo$nodeID[as.logical(nodeInfo$fromChip)]
selectNodes(cw, orgNodes, preserve.current.selection=FALSE)
```

OK, where do the AKT(1, 2, 3) genes show up, and what are their second neighbors?

```{r aktGenes}
aktNodes <- nodeInfo$nodeID[(nodeInfo$SYMBOL %in% c("AKT1", "AKT2", "AKT3"))]
selectNodes(cw, aktNodes, preserve.current.selection=FALSE)
selectFirstNeighborsOfSelectedNodes(cw)
selectFirstNeighborsOfSelectedNodes(cw)
```


## Communities

What about any communities in the graph? 

Note that multiple community detection algorithms were tried (edge-betweenness, label-propagation, and walktrap), and the results from the **walktrap** algorithm are actually used in subsequent analyses.

```{r walktrap}
commGraph <- igraph.from.graphNEL(stringGraph)
wtComm <- walktrap.community(commGraph)
wtAll <- communityAsList(wtComm)
```

```{r selectWT}
selectNodes(cw, wtAll[[1]], preserve.current.selection=FALSE)
selectNodes(cw, wtAll[[2]], preserve.current.selection=FALSE)
selectNodes(cw, wtAll[[3]], preserve.current.selection=FALSE)
```

Which community has the AKT? genes in it?

```{r commAKT}
sapply(wtAll, function(x){
  sum(x %in% aktNodes)
})
```

Cluster 1 has two of the AKT genes in it. Which ones are they?

```{r whichAKT, echo=FALSE, results='asis'}
whichAKT <- nodeInfo[(nodeInfo$nodeID %in% (wtAll[[1]][wtAll[[1]] %in% aktNodes])),]
print(xtable(whichAKT), type="html", html.table.attributes='style = "border-spacing:20px 5x;"', include.rownames=FALSE)
```

And which genes from the original array are also in this cluster?

```{r whichOrg}
whichOrg <- nodeInfo[(as.logical(nodeInfo$fromChip) & (nodeInfo$nodeID %in% wtAll[[1]])),]
print(xtable(whichOrg), type="html", html.table.attributes='style = "border-spacing:20px 5x;"', include.rownames=FALSE)
```

Working with just the first community, which genes are connected to AKT1,3? We will allow two links out.

```{r comm1AKT}
comm1Graph <- subGraph(wtAll[[1]], stringGraph)
connAKT <- adj(comm1Graph, aktNodes)
aktLink1 <- unlist(connAKT)
connAKT <- adj(comm1Graph, aktLink1)
aktLink2 <- unique(unlist(connAKT))
aktLink2 <- aktLink2[!(aktLink2 %in% aktLink1)]

nodeComm1 <- nodeInfo[(nodeInfo$nodeID %in% wtAll[[1]]),]
nodeComm1$link2AKT <- 0
nodeComm1$link2AKT[nodeComm1$nodeID %in% aktLink1] <- 1
nodeComm1$link2AKT[nodeComm1$nodeID %in% aktLink2] <- 2
```

```{r printComm1AKT, echo=FALSE, results='asis'}
print(xtable(nodeComm1), type="html", html.table.attributes='style = "border-spacing:20px 5x;"', include.rownames=FALSE)
```

### Community Characterization

Can we characterize the three biggest communities using the Gene Ontology?

```{r setUpLists}
gUniverse <- mappedkeys(org.Hs.egENSEMBLPROT)
wtLists <- lapply(wtAll[seq(1,3)], function(inComm){
  commGenes <- unique(nodeInfo$ENTREZID[nodeInfo$nodeID %in% inComm])
  list(genes=commGenes, universe=gUniverse, annotation="org.Hs.eg.db")
})
names(wtLists) <- paste("C", seq(1,3), sep="")
wtLists <- new("ccGeneList", wtLists, ccType=c("BP", "MF", "CC"))
```

```{r runEnrichment}
wtEnrich <- ccEnrich(wtLists)
pvalueCutoff(wtEnrich$BP) <- 0.01
wtOpts <- new("ccOptions", listNames=names(wtLists))
wtCompare <- ccCompare(wtEnrich, wtOpts)
```

```{r visCompare}
wtCompare$BP <- breakEdges(wtCompare$BP, 0.8)
wtBP <- ccOutCyt(wtCompare$BP, wtOpts, postText="wtBP")
breakEdges(wtBP, 1)

wtMF <- ccOutCyt(wtCompare$MF, wtOpts)
breakEdges(wtMF, 0.8)

wtCC <- ccOutCyt(wtCompare$CC, wtOpts)
breakEdges(wtCC, 0.8)
```

This doesn't seem to be helping us a whole lot. 

### Interactions via STRINGDB Summary

There are a lot of genes that interact with a few of the measured genes that also interact with AKT1 and AKT3. 


## KEGG Pathways

Lets query the specific KEGG Pathways that all of our genes are involved in, and then see what else is around that may be interesting.

```{r queryKEGG, eval=FALSE}
keggGenes <- paste("hsa", outMRNA$ENTREZID, sep=":")
outMRNAPathways <- keggLink("pathway", keggGenes)
allPaths <- unique(outMRNAPathways)
allPaths <- substring(allPaths, 6)
allKGML <- lapply(allPaths, function(x){
  keggGet(x, "kgml")
})

names(allKGML) <- allPaths
save(allKGML, file="inst/data/allKGML.RData")
```

```{r parseandExpand}
data(allKGML)
allGraphs <- lapply(allKGML, function(x){
  parseKGML2Graph(x, genesOnly=FALSE, expandGenes=TRUE)
})
```

Do any of these involve the AKT1, 2, 3 genes?

```{r AKTGenes}
aktEntrez <- nodeInfo$ENTREZID[grep("AKT", nodeInfo$SYMBOL)]
stripHSA <- function(nodeNames){
  startHSA <- grep("^hsa", nodeNames, value=TRUE)
  substring(startHSA, 5)
}
hasAKT <- sapply(allGraphs, function(x){
  sum(aktEntrez %in% stripHSA(nodes(x))) > 0
})
```

Yes indeed, there are `r sum(hasAKT)` pathways that have the AKT genes in them directly. 

Can we merge and plot the pathways?

```{r mergePaths}
mergePaths <- mergeKEGGgraphs(allGraphs)
```

